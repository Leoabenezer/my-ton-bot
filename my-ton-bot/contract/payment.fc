;; ============================================
;; SIMPLE PAYMENT RECEIVER CONTRACT
;; ============================================

;; This contract just receives payments
;; and stores them for verification

#include "stdlib.fc";

;; Minimum payment (1 TON)
const int MIN_PAYMENT = 1000000000;

;; Storage: just keep owner address
(slice) load_data() inline {
    slice ds = get_data().begin_parse();
    return ds~load_msg_addr();
}

() save_data(slice owner) impure inline {
    set_data(begin_cell()
        .store_slice(owner)
    .end_cell());
}

;; Receive payment
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    
    ;; Parse sender
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender = cs~load_msg_addr();
    
    ;; Check minimum payment
    throw_unless(101, msg_value >= MIN_PAYMENT);
    
    ;; Payment received! 
    ;; The transaction is now on blockchain
    ;; Bot can verify by checking transactions to this contract
    
    ;; Optional: emit event for easier tracking
    ;; (comment/payload is already in the transaction)
    
    return ();
}

;; Withdraw funds (only owner)
() withdraw(slice owner_address, int amount) impure {
    slice owner = load_data();
    throw_unless(102, equal_slice_bits(owner, owner_address));
    
    send_raw_message(
        begin_cell()
            .store_uint(0x10, 6)
            .store_slice(owner)
            .store_coins(amount)
            .store_uint(0, 107)
        .end_cell(),
        1
    );
}